#用和、差的互质子序列进行处理

###互质子序列的设计，

- 互质间隔下，ULA能取到更长，生成更大的虚拟阵列  

- 差子序列由自相关生成  

差子序列生成后，用矢量化方法，求出新的阵列流型:[K-R积](https://en.wikipedia.org/wiki/Kronecker_product#Matrix_equations)  

- Kronecker积，矩阵A(m,n)、B(p,q)的Kronecker积定义为，A中每一个元素乘B整个矩阵，结果是(mp,nq）大小的新矩阵  
- Khatri-Rao积，将A、B划分为几个子矩阵，子矩阵可以是行向量、列向量、一般矩阵，然后将**对应子矩阵**（类似内积一样对应）求Kronecker积。在子矩阵中操作对应上一步  

以上步骤，将原实际阵列的接收数据，处理成模拟的差子序列阵列接收信号  

在本文处理中，阵列流型也用列向量来划分。**每一列是不同阵元对同一个信号的增益、相位延迟。**  因此，整个阵列流型看成是一个行向量，元素是上述列向量。  

差子序列，通过K-R积产生，两个矩阵分别取A^*和A。在相位上共轭使得相位部分取复数，体现为相减，也就是作差。

- 在生成新的虚拟阵列流型、虚拟噪声后，采用空间平滑处理(spatial smoothing technique)

---
###空间平滑处理
介绍阵列信号基本模型以及两点性质
- 自相关处理后，进行特征值分解，当阵元数量q>信源数量p时，并且阵元间距满足小于半波长，保证阵元间的接收信号线性独立。则有，特征值分解后，大的特征值为信源功率、小的特征值为噪声功率
- 噪声特征值子空间与阵元特征值子空间（也等于信源特征值子空间）互相正交、互不相关。

以上处理假设的条件比较苛刻，要求信源的协方差矩阵**非奇异**。
[奇异矩阵singular matrix](https://en.wikipedia.org/wiki/Invertible_matrix)

**性质**  

- 方阵
- 行列式值为0为奇异矩阵，否则非奇异  

当信源的协方差矩阵不满足非奇异条件时，也就是说该矩阵不满秩，换句话说就是矩阵中，部分信源信号有相关性  
*使用DOF的平均值处理解决信源信号间的相关性问题*

---
###MUSIC算法仿真
- **原理**  
信号子空间、噪声子空间互相正交。因此信号子空间中的导向矢量，即对应阵列流型中的一列，与噪声子空间正交。MUSIC算法计算两者的模（即相乘后的因子，在与其共轭相乘）,再取倒数。通过正交，可知在峰值处，就是阵列角度，对应信源。

- 算法  
1. 由阵列的接收数据，作协方差矩阵R
2. 对R进行特征分解
3. 由R的特征值对信源数量进行判断，有几个特征值就有几个信源
4. 确定信号子空间、噪声子空间。信号子空间的特征值更大，噪声子空间的特征值更小且都接近噪声功率
5. 计算谱估计，即阵列矢量乘噪声空间，做模再取倒数
6. 极大值点就是信号入射方向

---
###COARRAY MUSIC ALGORITHM by Chun-Lin Liu
- 主函数  

1. 阵列配置，M、N分配为互质最小间隔，设置的阵元阵列是取差，第一列是以M为最小间隔，第二列是以N为最小间隔。这里的配置用到**Extended Co-prime Arrays**部署的阵列。(0:N-1)M以及延展的(0:2M-1)N  

2. 生成阵列输出，先模拟真实DOA，在-0.49到0.49*（弧度？正弦值？）*内均匀部署35个信源。设置快拍数*（相当于采样样本？）*、信噪比

- MUSIC算法

1. norm，返回矩阵范数，norm(A)默认返回矩阵的2-范数，即A.*A'然后取乘积的最大特征值，该特征值取根号。norm(A,1)返回1-范数，即A的最大列的和，其中A的元素全都要取绝对值  

2. flipud，行翻转，对称轴为中间行，最后一行与第一行交换，以此类推。如果是列向量，则向量整个翻转；如果是行向量，则不变

3. 第一步判断hermitian矩阵

---
###MATLAB 部分

- histc 划分

- 矩阵索引A(二进制矩阵B)，A按行取B中为1的数，输出列向量

- eig奇异值分解，e = eig (A)、[V,D] = eig (A); A为方阵，返回e为一列向量，值为A的所有特征值；V为矩阵，其列是相应的特征向量，D为对角化的矩阵，对应为A*V=V*D；即D为堆成矩阵A的对角化；

- 子阵阵元数量必须大于信源数，子阵数量也要大于阵元数量

- [奇异值分解和特征值分解](https://blog.csdn.net/ksearch/article/details/19398119)  